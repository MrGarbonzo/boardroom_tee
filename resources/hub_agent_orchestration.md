# Agent Orchestration with Unified Hub LLM\n\n## Overview\nThe same Llama-3.2-1B-Instruct model that processes documents also handles intelligent agent-to-agent orchestration and routing.\n\n---\n\n## Agent Orchestration Architecture\n\n### Unified Orchestration System\n```python\nfrom typing import Dict, List, Optional\nimport json\nfrom datetime import datetime\n\nclass AgentOrchestrator:\n    \"\"\"Handle agent-to-agent communication routing using unified hub LLM\"\"\"\n    \n    def __init__(self, hub_llm: UnifiedHubLLM):\n        self.hub_llm = hub_llm\n        self.agent_registry = {\n            \"finance\": {\n                \"capabilities\": [\"financial_analysis\", \"budget_planning\", \"roi_calculation\", \"risk_assessment\"],\n                \"specialties\": [\"cash_flow\", \"profitability\", \"compliance\", \"forecasting\"],\n                \"endpoint\": \"http://finance-agent:8081\"\n            },\n            \"marketing\": {\n                \"capabilities\": [\"campaign_analysis\", \"customer_segmentation\", \"roi_analysis\", \"attribution_modeling\"],\n                \"specialties\": [\"digital_marketing\", \"content_strategy\", \"customer_acquisition\"],\n                \"endpoint\": \"http://marketing-agent:8082\"\n            },\n            \"sales\": {\n                \"capabilities\": [\"pipeline_forecasting\", \"deal_analysis\", \"performance_analysis\", \"territory_planning\"],\n                \"specialties\": [\"deal_management\", \"quota_planning\", \"customer_health\"],\n                \"endpoint\": \"http://sales-agent:8083\"\n            },\n            \"ceo\": {\n                \"capabilities\": [\"strategic_analysis\", \"cross_functional_synthesis\", \"board_reporting\", \"scenario_planning\"],\n                \"specialties\": [\"strategic_planning\", \"competitive_intelligence\", \"executive_decision_support\"],\n                \"endpoint\": \"http://ceo-agent:8084\"\n            }\n        }\n    \n    def create_routing_prompt(self, query: str, requesting_agent: str) -> str:\n        \"\"\"Create prompt for intelligent agent routing\"\"\"\n        \n        available_agents = {k: v for k, v in self.agent_registry.items() if k != requesting_agent}\n        \n        prompt = f\"\"\"<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are an intelligent agent orchestrator. Analyze requests and determine the optimal workflow for agent collaboration.\n\n<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nAgent Request Analysis:\nRequesting Agent: {requesting_agent}\nQuery: \"{query}\"\n\nAvailable Agents and Capabilities:\n{json.dumps(available_agents, indent=2)}\n\nDetermine the optimal collaboration workflow. Consider:\n1. Which agent(s) should handle this request?\n2. Should this be sequential or parallel processing?\n3. What specific analysis should each agent provide?\n4. How should conflicts between agents be resolved?\n\nRespond with ONLY valid JSON in this format:\n{{\n  \"workflow_type\": \"sequential|parallel|single\",\n  \"agents\": [\n    {{\n      \"agent\": \"finance\",\n      \"task\": \"Analyze budget impact and ROI projections\",\n      \"priority\": 1,\n      \"depends_on\": [],\n      \"data_needed\": [\"budget_data\", \"campaign_costs\"]\n    }}\n  ],\n  \"reasoning\": \"Brief explanation of routing decision\",\n  \"estimated_time_minutes\": 5,\n  \"conflict_resolution\": \"finance_priority|consensus_required|ceo_decides\"\n}}\n\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n\"\"\"\n        return prompt\n    \n    def route_agent_request(self, query: str, requesting_agent: str) -> Dict:\n        \"\"\"Route collaboration request using LLM intelligence\"\"\"\n        try:\n            model, tokenizer = self.hub_llm.get_model()\n            \n            # Create routing prompt\n            prompt = self.create_routing_prompt(query, requesting_agent)\n            \n            # Generate routing decision\n            inputs = tokenizer(\n                prompt,\n                return_tensors=\"pt\",\n                truncation=True,\n                max_length=4096,\n                padding=True\n            )\n            \n            with torch.no_grad():\n                outputs = model.generate(\n                    **inputs,\n                    max_new_tokens=400,\n                    temperature=0.1,\n                    do_sample=True,\n                    pad_token_id=tokenizer.eos_token_id,\n                    eos_token_id=tokenizer.eos_token_id\n                )\n            \n            response = tokenizer.decode(outputs[0], skip_special_tokens=True)\n            \n            # Extract JSON from response\n            json_start = response.find('{')\n            if json_start != -1:\n                json_text = response[json_start:]\n                json_end = json_text.rfind('}') + 1\n                json_text = json_text[:json_end]\n                \n                routing_decision = json.loads(json_text)\n                \n                # Add metadata\n                routing_decision.update({\n                    \"routed_at\": datetime.utcnow().isoformat(),\n                    \"requesting_agent\": requesting_agent,\n                    \"original_query\": query,\n                    \"routing_method\": \"llm_intelligent\"\n                })\n                \n                return routing_decision\n            else:\n                # Fallback to simple routing\n                return self.simple_fallback_routing(query, requesting_agent)\n                \n        except Exception as e:\n            # Fallback routing if LLM fails\n            return self.simple_fallback_routing(query, requesting_agent, str(e))\n    \n    def simple_fallback_routing(self, query: str, requesting_agent: str, error: str = None) -> Dict:\n        \"\"\"Simple keyword-based routing fallback\"\"\"\n        query_lower = query.lower()\n        target_agents = []\n        \n        # Simple keyword matching\n        if any(term in query_lower for term in ['budget', 'cost', 'revenue', 'financial', 'roi', 'profit']):\n            target_agents.append(\"finance\")\n        \n        if any(term in query_lower for term in ['campaign', 'marketing', 'customer', 'acquisition', 'conversion']):\n            target_agents.append(\"marketing\")\n        \n        if any(term in query_lower for term in ['sales', 'pipeline', 'deal', 'quota', 'forecast']):\n            target_agents.append(\"sales\")\n        \n        if any(term in query_lower for term in ['strategy', 'board', 'executive', 'strategic', 'competitive']):\n            target_agents.append(\"ceo\")\n        \n        # Remove requesting agent\n        target_agents = [agent for agent in target_agents if agent != requesting_agent]\n        \n        # Default to finance if no matches\n        if not target_agents:\n            target_agents = [\"finance\"]\n        \n        return {\n            \"workflow_type\": \"sequential\" if len(target_agents) > 1 else \"single\",\n            \"agents\": [\n                {\n                    \"agent\": agent,\n                    \"task\": f\"Analyze request: {query[:100]}...\",\n                    \"priority\": i + 1,\n                    \"depends_on\": [],\n                    \"data_needed\": [\"relevant_data\"]\n                }\n                for i, agent in enumerate(target_agents)\n            ],\n            \"reasoning\": f\"Fallback keyword-based routing{' due to error: ' + error if error else ''}\",\n            \"estimated_time_minutes\": len(target_agents) * 3,\n            \"conflict_resolution\": \"consensus_required\",\n            \"routed_at\": datetime.utcnow().isoformat(),\n            \"requesting_agent\": requesting_agent,\n            \"original_query\": query,\n            \"routing_method\": \"fallback_keywords\",\n            \"fallback_used\": True\n        }\n\n# Example Usage Scenarios\nclass OrchestrationExamples:\n    \"\"\"Examples of agent orchestration scenarios\"\"\"\n    \n    @staticmethod\n    def scenario_marketing_roi_analysis():\n        \"\"\"Finance agent requests marketing ROI analysis\"\"\"\n        return {\n            \"requesting_agent\": \"finance\",\n            \"query\": \"I need ROI analysis for our Q4 holiday marketing campaign to validate budget allocation\",\n            \"expected_routing\": {\n                \"workflow_type\": \"sequential\",\n                \"agents\": [\n                    {\n                        \"agent\": \"marketing\",\n                        \"task\": \"Analyze Q4 holiday campaign performance and calculate ROI metrics\",\n                        \"priority\": 1,\n                        \"data_needed\": [\"campaign_data\", \"customer_acquisition_costs\", \"conversion_rates\"]\n                    }\n                ]\n            }\n        }\n    \n    @staticmethod\n    def scenario_acquisition_analysis():\n        \"\"\"CEO agent requests comprehensive acquisition analysis\"\"\"\n        return {\n            \"requesting_agent\": \"ceo\",\n            \"query\": \"Should we acquire Company X? I need comprehensive analysis of financial impact, market implications, and integration complexity\",\n            \"expected_routing\": {\n                \"workflow_type\": \"parallel\",\n                \"agents\": [\n                    {\n                        \"agent\": \"finance\",\n                        \"task\": \"Analyze financial impact, valuation, and deal structure\",\n                        \"priority\": 1,\n                        \"data_needed\": [\"financial_statements\", \"valuation_models\", \"cash_flow_projections\"]\n                    },\n                    {\n                        \"agent\": \"sales\",\n                        \"task\": \"Evaluate market impact and customer overlap\",\n                        \"priority\": 1,\n                        \"data_needed\": [\"customer_data\", \"market_analysis\", \"competitive_landscape\"]\n                    },\n                    {\n                        \"agent\": \"marketing\",\n                        \"task\": \"Assess brand integration and market positioning\",\n                        \"priority\": 2,\n                        \"depends_on\": [\"sales\"],\n                        \"data_needed\": [\"brand_analysis\", \"customer_segments\", \"marketing_synergies\"]\n                    }\n                ]\n            }\n        }\n    \n    @staticmethod\n    def scenario_budget_optimization():\n        \"\"\"Marketing agent requests budget optimization insights\"\"\"\n        return {\n            \"requesting_agent\": \"marketing\",\n            \"query\": \"How should I reallocate my Q1 marketing budget across digital channels for maximum ROI?\",\n            \"expected_routing\": {\n                \"workflow_type\": \"sequential\",\n                \"agents\": [\n                    {\n                        \"agent\": \"finance\",\n                        \"task\": \"Provide current budget constraints and ROI requirements\",\n                        \"priority\": 1,\n                        \"data_needed\": [\"marketing_budget\", \"financial_targets\", \"roi_benchmarks\"]\n                    },\n                    {\n                        \"agent\": \"sales\",\n                        \"task\": \"Analyze which channels drive highest-quality leads\",\n                        \"priority\": 2,\n                        \"depends_on\": [\"finance\"],\n                        \"data_needed\": [\"lead_sources\", \"conversion_rates\", \"customer_quality_metrics\"]\n                    }\n                ]\n            }\n        }\n\n```\n\n---\n\n## Integration with Hub Operations\n\n### Hub Service Integration\n```python\nclass UnifiedHubService:\n    \"\"\"Main hub service integrating document processing and agent orchestration\"\"\"\n    \n    def __init__(self):\n        self.hub_llm = UnifiedHubLLM()\n        self.document_processor = DocumentCategorizer(self.hub_llm)\n        self.agent_orchestrator = AgentOrchestrator(self.hub_llm)\n        self.data_storage = None  # Initialize with client-specific storage\n    \n    async def handle_document_upload(self, file_data: bytes, filename: str, client_id: str):\n        \"\"\"Process uploaded document\"\"\"\n        try:\n            # Extract content\n            extractor = ContentExtractor()\n            content = extractor.extract_content(file_data, mime_type)\n            \n            # Categorize with LLM\n            categorization = self.document_processor.process_document(content, filename)\n            \n            # Store in database\n            storage = HubDataStorage(client_id, Path(\"/app/data/storage\"))\n            doc_id = storage.store_document(file_data, content, metadata, categorization)\n            \n            return {\n                \"status\": \"success\",\n                \"document_id\": doc_id,\n                \"categorization\": categorization\n            }\n            \n        except Exception as e:\n            return {\n                \"status\": \"error\",\n                \"error\": str(e)\n            }\n    \n    async def handle_agent_collaboration_request(self, request: Dict):\n        \"\"\"Handle agent-to-agent collaboration request\"\"\"\n        try:\n            # Route the request using LLM\n            routing_decision = self.agent_orchestrator.route_agent_request(\n                request['query'],\n                request['requesting_agent']\n            )\n            \n            return {\n                \"status\": \"success\",\n                \"routing_decision\": routing_decision\n            }\n            \n        except Exception as e:\n            return {\n                \"status\": \"error\",\n                \"error\": str(e)\n            }\n    \n    def get_system_status(self):\n        \"\"\"Get overall system status\"\"\"\n        return {\n            \"hub_llm\": self.hub_llm.get_memory_usage(),\n            \"capabilities\": {\n                \"document_processing\": True,\n                \"agent_orchestration\": True,\n                \"unified_model\": True\n            },\n            \"model_info\": {\n                \"name\": \"Llama-3.2-1B-Instruct\",\n                \"instance_size\": \"medium\",\n                \"memory_optimized\": True\n            }\n        }\n```\n\n---\n\n## Performance Considerations\n\n### Memory Optimization\n- **Single Model**: ~2GB RAM usage, leaving 2GB for processing\n- **Shared Context**: Same model handles both document and orchestration tasks\n- **Efficient Inference**: Optimized for CPU-only inference in TEE\n- **Memory Cleanup**: Automatic garbage collection after operations\n\n### Response Time Targets\n- **Document Categorization**: 10-30 seconds per document\n- **Agent Routing**: 3-10 seconds per request\n- **Batch Document Processing**: 2-24 hours for complete upload batches\n- **Real-time Orchestration**: Always available for agent requests\n\n### Scalability Features\n- **Concurrent Operations**: Can handle document processing and agent routing simultaneously\n- **Efficient Resource Usage**: Single model reduces memory fragmentation\n- **Fallback Mechanisms**: Simple routing when LLM unavailable\n- **Monitoring**: Built-in memory usage and performance tracking\n\n---\n\n*Last Updated: [Current Date]*  \n*Related: hub_data_processing.md, spoke_agents.md, agent_collaboration.md*\n