"""Attestation client for TEE quote generation and verification."""

import os
import json
import logging
import hashlib
import base64
from datetime import datetime, timedelta
from typing import Dict, Optional, Tuple
import uuid

logger = logging.getLogger(__name__)


class AttestationClient:
    """Handle TEE attestation quote generation and verification."""
    
    def __init__(self, attestation_dir: str = "/app/crypto"):
        self.attestation_dir = attestation_dir
        self.development_mode = os.getenv('DEVELOPMENT_MODE', 'false').lower() == 'true'
        self.mock_attestation = os.getenv('MOCK_TEE_ATTESTATION', 'false').lower() == 'true'
        
        # Create attestation directory if it doesn't exist
        os.makedirs(self.attestation_dir, exist_ok=True)
    
    def generate_attestation_quote(self, user_data: str = "") -> Dict:
        """Generate TEE attestation quote (mocked for development)."""
        if self.development_mode or self.mock_attestation:
            logger.info("Development mode: Generating mock attestation quote")
            return self._generate_mock_quote(user_data)
        else:
            logger.info("Production mode: Generating real TEE attestation quote")
            return self._generate_real_quote(user_data)
    
    def _generate_mock_quote(self, user_data: str) -> Dict:
        """Generate a mock attestation quote for development."""
        try:
            # Create mock measurements
            mock_measurements = {
                "mr_enclave": hashlib.sha256(f"mock_enclave_{uuid.uuid4()}".encode()).hexdigest(),
                "mr_signer": hashlib.sha256("mock_signer_boardroom_tee".encode()).hexdigest(),
                "isv_prod_id": 1,
                "isv_svn": 1,
                "report_data": hashlib.sha256(user_data.encode()).hexdigest() if user_data else "0" * 64
            }
            
            # Create mock quote structure
            mock_quote = {
                "version": 3,
                "sign_type": 2,  # ECDSA256-with-P256
                "epid_group_id": "00000000",
                "qe_svn": 2,
                "pce_svn": 11,
                "xeid": "00000000",
                "basename": base64.b64encode(b"mock_basename").decode(),
                "report_body": {
                    "cpu_svn": "00000000000000000000000000000000",
                    "misc_select": "00000000",
                    "attributes": {
                        "flags": "0500000000000000",
                        "xfrm": "0700000000000000"
                    },
                    "mr_enclave": mock_measurements["mr_enclave"],
                    "mr_signer": mock_measurements["mr_signer"],
                    "isv_prod_id": mock_measurements["isv_prod_id"],
                    "isv_svn": mock_measurements["isv_svn"],
                    "report_data": mock_measurements["report_data"]
                },
                "signature": base64.b64encode(b"mock_signature").decode(),
                "timestamp": datetime.utcnow().isoformat()
            }
            
            # Save quote to file
            quote_path = os.path.join(self.attestation_dir, "quote.txt")
            quote_json = json.dumps(mock_quote, indent=2)
            quote_b64 = base64.b64encode(quote_json.encode()).decode()
            
            with open(quote_path, 'w') as f:
                f.write(quote_b64)
            
            logger.info("Mock attestation quote generated successfully")
            return {
                "quote": quote_b64,
                "quote_type": "mock",
                "measurements": mock_measurements,
                "timestamp": mock_quote["timestamp"]
            }
            
        except Exception as e:
            logger.error(f"Failed to generate mock quote: {e}")
            raise
    
    def _generate_real_quote(self, user_data: str) -> Dict:
        """Generate real TEE attestation quote using SecretVM."""
        try:
            # In production, SecretVM generates the quote at:
            # /app/crypto/docker_attestation_ed25519.txt
            
            quote_path = os.path.join(self.attestation_dir, "docker_attestation_ed25519.txt")
            
            if not os.path.exists(quote_path):
                raise Exception("TEE attestation quote not yet generated by SecretVM")
            
            with open(quote_path, 'r') as f:
                quote_b64 = f.read().strip()
            
            # Parse the quote to extract measurements
            quote_data = json.loads(base64.b64decode(quote_b64))
            
            measurements = {
                "mr_enclave": quote_data["report_body"]["mr_enclave"],
                "mr_signer": quote_data["report_body"]["mr_signer"],
                "isv_prod_id": quote_data["report_body"]["isv_prod_id"],
                "isv_svn": quote_data["report_body"]["isv_svn"],
                "report_data": quote_data["report_body"]["report_data"]
            }
            
            logger.info("Real TEE attestation quote loaded successfully")
            return {
                "quote": quote_b64,
                "quote_type": "tdx",  # or "sev" depending on platform
                "measurements": measurements,
                "timestamp": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Failed to load TEE quote: {e}")
            raise
    
    def verify_attestation_quote(self, quote_b64: str, expected_measurements: Optional[Dict] = None) -> Tuple[bool, Dict]:
        """Verify an attestation quote."""
        if self.development_mode or self.mock_attestation:
            return self._verify_mock_quote(quote_b64, expected_measurements)
        else:
            return self._verify_real_quote(quote_b64, expected_measurements)
    
    def _verify_mock_quote(self, quote_b64: str, expected_measurements: Optional[Dict]) -> Tuple[bool, Dict]:
        """Verify a mock attestation quote."""
        try:
            # Decode and parse the quote
            quote_json = base64.b64decode(quote_b64).decode()
            quote_data = json.loads(quote_json)
            
            # Basic structure validation
            required_fields = ["version", "report_body", "signature", "timestamp"]
            for field in required_fields:
                if field not in quote_data:
                    return False, {"error": f"Missing required field: {field}"}
            
            # Check timestamp freshness (within 1 hour)
            quote_time = datetime.fromisoformat(quote_data["timestamp"])
            if datetime.utcnow() - quote_time > timedelta(hours=1):
                return False, {"error": "Quote timestamp too old"}
            
            # Extract measurements
            measurements = {
                "mr_enclave": quote_data["report_body"]["mr_enclave"],
                "mr_signer": quote_data["report_body"]["mr_signer"],
                "isv_prod_id": quote_data["report_body"]["isv_prod_id"],
                "isv_svn": quote_data["report_body"]["isv_svn"],
                "report_data": quote_data["report_body"]["report_data"]
            }
            
            # Verify expected measurements if provided
            if expected_measurements:
                for key, expected_value in expected_measurements.items():
                    if key in measurements and measurements[key] != expected_value:
                        return False, {
                            "error": f"Measurement mismatch for {key}",
                            "expected": expected_value,
                            "actual": measurements[key]
                        }
            
            logger.info("Mock attestation quote verified successfully")
            return True, {
                "verified": True,
                "quote_type": "mock",
                "measurements": measurements,
                "timestamp": quote_data["timestamp"]
            }
            
        except Exception as e:
            logger.error(f"Failed to verify mock quote: {e}")
            return False, {"error": str(e)}
    
    def _verify_real_quote(self, quote_b64: str, expected_measurements: Optional[Dict]) -> Tuple[bool, Dict]:
        """Verify real TEE attestation quote."""
        # In production, this would:
        # 1. Decode the quote
        # 2. Verify the quote signature using Intel/AMD attestation service
        # 3. Check measurements against expected values
        # 4. Verify certificate chain
        
        # For now, perform basic validation
        try:
            quote_json = base64.b64decode(quote_b64).decode()
            quote_data = json.loads(quote_json)
            
            # Extract measurements
            measurements = {
                "mr_enclave": quote_data["report_body"]["mr_enclave"],
                "mr_signer": quote_data["report_body"]["mr_signer"],
                "isv_prod_id": quote_data["report_body"]["isv_prod_id"],
                "isv_svn": quote_data["report_body"]["isv_svn"],
                "report_data": quote_data["report_body"]["report_data"]
            }
            
            # In production, would verify with attestation service
            # For now, return success with measurements
            return True, {
                "verified": True,
                "quote_type": "tdx",
                "measurements": measurements,
                "timestamp": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Failed to verify real quote: {e}")
            return False, {"error": str(e)}
    
    def get_attestation_endpoint_data(self) -> Dict:
        """Get data for the attestation endpoint."""
        try:
            quote_data = self.generate_attestation_quote()
            
            return {
                "status": "healthy",
                "attestation": {
                    "platform": "Intel TDX" if not self.development_mode else "Mock TEE",
                    "quote_available": True,
                    "quote_type": quote_data["quote_type"],
                    "measurements": quote_data["measurements"],
                    "timestamp": quote_data["timestamp"]
                },
                "development_mode": self.development_mode
            }
            
        except Exception as e:
            return {
                "status": "unhealthy",
                "error": str(e),
                "development_mode": self.development_mode
            }