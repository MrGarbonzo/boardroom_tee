"""TEE Key Manager for secure key generation and management."""

import os
import logging
from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from typing import Tuple, Optional
import base64

logger = logging.getLogger(__name__)


class TEEKeyManager:
    """Manage ed25519 keys for TEE environments with development mocking."""
    
    def __init__(self, key_dir: str = "/app/crypto"):
        self.key_dir = key_dir
        self.development_mode = os.getenv('DEVELOPMENT_MODE', 'false').lower() == 'true'
        self.private_key = None
        self.public_key = None
        
        # Create key directory if it doesn't exist
        os.makedirs(self.key_dir, exist_ok=True)
        
    def generate_tee_keys(self) -> Tuple[str, str]:
        """Generate ed25519 key pair within TEE (mocked for development)."""
        if self.development_mode:
            logger.info("Development mode: Generating mock ed25519 keys")
            return self._mock_key_generation()
        else:
            logger.info("Production mode: Generating TEE-protected keys")
            return self._real_tee_key_generation()
    
    def _mock_key_generation(self) -> Tuple[str, str]:
        """Generate regular ed25519 keys for development."""
        try:
            # Generate new key pair
            private_key = ed25519.Ed25519PrivateKey.generate()
            public_key = private_key.public_key()
            
            # Serialize private key
            private_pem = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            )
            
            # Serialize public key
            public_pem = public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
            
            # Save keys to files
            private_key_path = os.path.join(self.key_dir, "privkey.pem")
            public_key_path = os.path.join(self.key_dir, "pubkey.pem")
            
            with open(private_key_path, 'wb') as f:
                f.write(private_pem)
            
            with open(public_key_path, 'wb') as f:
                f.write(public_pem)
            
            # Store in memory
            self.private_key = private_key
            self.public_key = public_key
            
            logger.info("Mock keys generated successfully")
            return private_pem.decode(), public_pem.decode()
            
        except Exception as e:
            logger.error(f"Failed to generate mock keys: {e}")
            raise
    
    def _real_tee_key_generation(self) -> Tuple[str, str]:
        """Generate keys within TEE using SecretVM (production only)."""
        # In production, SecretVM automatically generates keys via volume mounts
        # Keys are created at:
        # - /app/crypto/docker_private_key_ed25519.pem
        # - /app/crypto/docker_public_key_ed25519.pem
        
        try:
            private_key_path = os.path.join(self.key_dir, "docker_private_key_ed25519.pem")
            public_key_path = os.path.join(self.key_dir, "docker_public_key_ed25519.pem")
            
            # Wait for SecretVM to generate keys
            if not os.path.exists(private_key_path) or not os.path.exists(public_key_path):
                raise Exception("TEE keys not yet generated by SecretVM")
            
            with open(private_key_path, 'rb') as f:
                private_pem = f.read()
            
            with open(public_key_path, 'rb') as f:
                public_pem = f.read()
            
            # Load keys into memory
            self.private_key = serialization.load_pem_private_key(
                private_pem, password=None, backend=default_backend()
            )
            self.public_key = serialization.load_pem_public_key(
                public_pem, backend=default_backend()
            )
            
            logger.info("TEE-protected keys loaded successfully")
            return private_pem.decode(), public_pem.decode()
            
        except Exception as e:
            logger.error(f"Failed to load TEE keys: {e}")
            raise
    
    def load_keys(self) -> bool:
        """Load existing keys from filesystem."""
        try:
            if self.development_mode:
                private_key_path = os.path.join(self.key_dir, "privkey.pem")
                public_key_path = os.path.join(self.key_dir, "pubkey.pem")
            else:
                private_key_path = os.path.join(self.key_dir, "docker_private_key_ed25519.pem")
                public_key_path = os.path.join(self.key_dir, "docker_public_key_ed25519.pem")
            
            if not os.path.exists(private_key_path) or not os.path.exists(public_key_path):
                logger.warning("Keys not found, generating new ones")
                self.generate_tee_keys()
                return True
            
            with open(private_key_path, 'rb') as f:
                private_pem = f.read()
            
            with open(public_key_path, 'rb') as f:
                public_pem = f.read()
            
            self.private_key = serialization.load_pem_private_key(
                private_pem, password=None, backend=default_backend()
            )
            self.public_key = serialization.load_pem_public_key(
                public_pem, backend=default_backend()
            )
            
            logger.info("Keys loaded successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to load keys: {e}")
            return False
    
    def sign_message(self, message: str) -> str:
        """Sign a message using the private key."""
        if not self.private_key:
            raise Exception("Private key not loaded")
        
        try:
            signature = self.private_key.sign(message.encode('utf-8'))
            return base64.b64encode(signature).decode('utf-8')
        except Exception as e:
            logger.error(f"Failed to sign message: {e}")
            raise
    
    def verify_signature(self, message: str, signature_b64: str, public_key_pem: str) -> bool:
        """Verify a message signature using a public key."""
        try:
            # Load the public key
            public_key = serialization.load_pem_public_key(
                public_key_pem.encode(), backend=default_backend()
            )
            
            # Decode the signature
            signature = base64.b64decode(signature_b64)
            
            # Verify
            public_key.verify(signature, message.encode('utf-8'))
            return True
            
        except Exception as e:
            logger.debug(f"Signature verification failed: {e}")
            return False
    
    def get_public_key_pem(self) -> str:
        """Get the public key in PEM format."""
        if not self.public_key:
            raise Exception("Public key not loaded")
        
        return self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode('utf-8')
    
    def get_key_fingerprint(self) -> str:
        """Get a fingerprint of the public key."""
        if not self.public_key:
            raise Exception("Public key not loaded")
        
        public_bytes = self.public_key.public_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PublicFormat.Raw
        )
        
        return base64.b64encode(public_bytes).decode('utf-8')[:16]